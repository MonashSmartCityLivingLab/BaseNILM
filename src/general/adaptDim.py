#######################################################################################################################
#######################################################################################################################
# Title:        BaseNILM toolkit for energy disaggregation
# Topic:        Non-intrusive load monitoring utilising machine learning, pattern matching and source separation
# File:         adaptDim
# Date:         23.05.2024
# Author:       Dr. Pascal A. Schirmer
# Version:      V.1.0
# Copyright:    Pascal Schirmer
#######################################################################################################################
#######################################################################################################################

#######################################################################################################################
# Function Description
#######################################################################################################################
"""
This function adapts the dimension of the input and output matrices depending on the model dimension.
Inputs:     1) X:       input feature vector (based on aggregated consumption)
            2) y:       output vector (electrical appliance consumption)
            3) setup:   includes all simulation variables
Outputs:    1) X:       adapted dimension input feature vector (based on aggregated consumption)
            2) y:       adapted dimension output vector (electrical appliance consumption)
            3) nDim:    dimension
            4) setup:   includes all simulation variables
"""

#######################################################################################################################
# Import libs
#######################################################################################################################
# ==============================================================================
# Internal
# ==============================================================================
from src.general.helpFnc import warnMsg

# ==============================================================================
# External
# ==============================================================================
from scipy import signal, interpolate
from tqdm import tqdm
import numpy as np


#######################################################################################################################
# Function
#######################################################################################################################
def adaptDim(X, y, setupPar, setupExp):
    ###################################################################################################################
    # MSG IN
    ###################################################################################################################
    print("INFO: Adapting data dimension")

    ###################################################################################################################
    # Initialisation
    ###################################################################################################################
    # ==============================================================================
    # Parameters
    # ==============================================================================
    dim = X.ndim - 1
    nDim = X.shape

    ###################################################################################################################
    # Calculation
    ###################################################################################################################
    # ==============================================================================
    # Collapsing Dimension X
    # ==============================================================================
    if setupPar['nDim'] == 3:
        # ------------------------------------------
        # Data Dim 3D
        # ------------------------------------------
        if dim == 3:
            Xout = X
            print("INFO: Features are 3D desired output is 3D")

        # ------------------------------------------
        # Data Dim 2D
        # ------------------------------------------
        elif dim == 2:
            Xout = X.reshape((nDim[0], nDim[1], nDim[2], 1))
            msg = "WARN: Features are 2D desired output is 3D, reshaping X=(dim0, dim1, dim2, 1)"
            setupExp = warnMsg(msg, 1, 1, setupExp)

        # ------------------------------------------
        # Data Dim 1D
        # ------------------------------------------
        else:
            Xout = X.reshape((nDim[0], nDim[1], 1, 1))
            msg = "WARN: Features are 1D desired output is 3D, reshaping X=(dim0, dim1, 1, 1)"
            setupExp = warnMsg(msg, 1, 1, setupExp)

    elif setupPar['nDim'] == 2:
        # ------------------------------------------
        # Data Dim 3D
        # ------------------------------------------
        if dim == 3:
            Xout = X.reshape((nDim[0], nDim[1] * nDim[2], nDim[3]))
            msg = "WARN: Features are 3D desired output is 2D, reshaping X=(dim0, dim1*dim2, dim3)"
            setupExp = warnMsg(msg, 1, 1, setupExp)

        # ------------------------------------------
        # Data Dim 2D
        # ------------------------------------------
        elif dim == 2:
            Xout = X
            print("INFO: Features are 2D desired output is 2D")

        # ------------------------------------------
        # Data Dim 1D
        # ------------------------------------------
        else:
            Xout = X.reshape((nDim[0], nDim[1], 1))
            msg = "WARN: Features are 1D desired output is 2D, reshaping X=(dim0, dim1, 1)"
            setupExp = warnMsg(msg, 1, 1, setupExp)

    else:
        # ------------------------------------------
        # Data Dim 3D
        # ------------------------------------------
        if dim == 3:
            Xout = X.reshape((nDim[0], nDim[1] * nDim[2] * nDim[3]))
            msg = "WARN: Features are 3D desired output is 1D, reshaping X=(dim0, dim1*dim2*dim3)"
            setupExp = warnMsg(msg, 1, 1, setupExp)

        # ------------------------------------------
        # Data Dim 2D
        # ------------------------------------------
        elif dim == 2:
            Xout = X.reshape((nDim[0], nDim[1] * nDim[2]))
            msg = "WARN: Features are 2D desired output is 1D, reshaping X=(dim0, dim1*dim2)"
            setupExp = warnMsg(msg, 1, 1, setupExp)

        # ------------------------------------------
        # Data Dim 1D
        # ------------------------------------------
        else:
            Xout = X
            print("INFO: Features are 1D desired output is 1D")

    # ==============================================================================
    # Collapsing Dimension y
    # ==============================================================================
    yout = y

    ###################################################################################################################
    # Return
    ###################################################################################################################
    return [Xout, yout, nDim, setupExp]


#######################################################################################################################
# Function
#######################################################################################################################
def adaptDimHF(X, setupDat, setupPar):
    ###################################################################################################################
    # MSG IN
    ###################################################################################################################
    print("INFO: Adapting HF data dimension")

    ###################################################################################################################
    # Initialisation
    ###################################################################################################################
    # ==============================================================================
    # Parameters
    # ==============================================================================
    W_in = setupDat['HF_W']
    W_out = setupPar['window']
    F = setupDat['HF_F']
    q = W_in / W_out

    # ==============================================================================
    # Variables
    # ==============================================================================
    t_in = np.linspace(0, 1/60, W_in)
    t_out = np.linspace(0, 1/60, W_out)
    Xout = np.zeros((X.shape[0], W_in, F))
    Xdown = np.zeros((X.shape[0], W_out, F))

    ###################################################################################################################
    # Pre-processing
    ###################################################################################################################
    # ==============================================================================
    # Feature
    # ==============================================================================
    for i in range(0, F):
        Xout[:, :, i] = X.values[:, i * W_in:i * W_in + W_in]

    ###################################################################################################################
    # Post-processing
    ###################################################################################################################
    # ==============================================================================
    # Integer
    # ==============================================================================
    if q.is_integer():
        # ------------------------------------------
        # Msg
        # ------------------------------------------
        print("INFO: Integer down-sampling with q: " + str(q))

        # ------------------------------------------
        # Calc
        # ------------------------------------------
        for i in tqdm(range(0, X.shape[0]), desc='Sampling'):
            for ii in range(0, F):
                Xdown[i, :, ii] = signal.decimate(Xout[i, :, ii], int(q))

    # ==============================================================================
    # Non-Integer
    # ==============================================================================
    else:
        # ------------------------------------------
        # Msg
        # ------------------------------------------
        print("INFO: Non-Integer down-sampling with q: " + str(q))

        # ------------------------------------------
        # Calc
        # ------------------------------------------
        for i in tqdm(range(0, X.shape[0]), desc='Sampling'):
            for ii in range(0, F):
                f = interpolate.interp1d(t_in, Xout[i, :, ii])
                Xdown[i, :, ii] = f(t_out)

    ###################################################################################################################
    # Return
    ###################################################################################################################
    return Xdown
