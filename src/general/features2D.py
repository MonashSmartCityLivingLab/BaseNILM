#######################################################################################################################
#######################################################################################################################
# Title:        BaseNILM toolkit for energy disaggregation
# Topic:        Non-intrusive load monitoring utilising machine learning, pattern matching and source separation
# File:         features2D
# Date:         23.05.2024
# Author:       Dr. Pascal A. Schirmer
# Version:      V.1.0
# Copyright:    Pascal Schirmer
#######################################################################################################################
#######################################################################################################################

#######################################################################################################################
# Function Description
#######################################################################################################################
"""
This function calculates two-dimensional features including VI trajectories, PQ planes, DFIA, recurrent plots, gramian
angular fields, and markov transition fields.
Inputs:     1) data:    input data
            2) feat:    feature selection
Outputs:    1) out:     output feature vector
"""

#######################################################################################################################
# Import libs
#######################################################################################################################
# ==============================================================================
# Internal
# ==============================================================================

# ==============================================================================
# External
# ==============================================================================
import numpy as np
from pyts.image import RecurrencePlot
from pyts.image import GramianAngularField
from pyts.image import MarkovTransitionField
from tqdm import tqdm


#######################################################################################################################
# Function
#######################################################################################################################
def features2D(data, feat):
    ###################################################################################################################
    # MSG IN
    ###################################################################################################################
    print("INFO: Calculating 2D features")

    ###################################################################################################################
    # Initialisation
    ###################################################################################################################
    # ==============================================================================
    # Parameters
    # ==============================================================================
    W = data.shape[1]
    nDim = data.ndim

    # ==============================================================================
    # Variables
    # ==============================================================================
    if nDim == 2 or feat['VI'] != 0 or feat['PQ'] != 0 or feat['DFIA'] == 1 or feat['DFIA'] == 2:
        out = np.zeros((data.shape[0], data.shape[1], data.shape[1]))
    else:
        out = np.zeros((data.shape[0], data.shape[1], data.shape[1], data.shape[2]))

    ###################################################################################################################
    # Calculation
    ###################################################################################################################
    # ==============================================================================
    # VI-Trajectory
    # ==============================================================================
    if feat['VI'] == 1:
        # ------------------------------------------
        # Init
        # ------------------------------------------
        i_max = 180
        v_max = 180
        d_i = i_max / data.shape[1]
        d_v = v_max / data.shape[1]

        # ------------------------------------------
        # Calc
        # ------------------------------------------
        for i in tqdm(range(0, data.shape[0]), desc='Features'):
            for ii in range(0, data.shape[1]):
                n_i = np.ceil((np.ceil(data[i, :, 1] / d_i) + data.shape[1] - 2) / 2)
                n_v = np.ceil((np.ceil(data[i, :, 0] / d_v) + data.shape[1] - 2) / 2)
                if 0 < n_i[ii] < data.shape[1] + 1 and 0 < n_v[ii] < data.shape[1] + 1:
                    out[i, int(n_i[ii]), int(n_v[ii])] = 1

    # ==============================================================================
    # Recurrent Plot (Rec)
    # ==============================================================================
    if feat['REC'] == 1 or feat['GAF'] == 1 or feat['MKF'] == 1:
        # ------------------------------------------
        # Init
        # ------------------------------------------
        if feat['REC'] == 1:
            transformer = RecurrencePlot()
        elif feat['GAF'] == 1:
            transformer = GramianAngularField()
        elif feat['MKF'] == 1:
            transformer = MarkovTransitionField()
        else:
            transformer = RecurrencePlot()

        # ------------------------------------------
        # 2D Input
        # ------------------------------------------
        if nDim == 2:
            for i in tqdm(range(0, data.shape[0]), desc='Features'):
                out[i, :, :] = transformer.transform(data[i, :].reshape(1, -1))

        # ------------------------------------------
        # 3D Input
        # ------------------------------------------
        if nDim == 3:
            for i in tqdm(range(0, data.shape[0]), desc='Features'):
                for ii in range(0, data.shape[3]):
                    out[i, :, :, ii] = transformer.transform(data[i, :, ii].reshape(1, -1))

    # ==============================================================================
    # Active-Reactive (PQ)
    # ==============================================================================
    if feat['PQ'] == 1:
        for i in tqdm(range(0, data.shape[0]), desc='Features'):
            out[i, :, :] = np.outer(data[i, :, 0], data[i, :, 1])
        out = np.concatenate((out, data), axis=2)

    elif feat['PQ'] == 2:
        for i in tqdm(range(0, data.shape[0]), desc='Features'):
            P = np.outer(data[i, :, 0], data[i, :, 0])
            Q = np.outer(data[i, :, 1], data[i, :, 1])
            out[i, :, :] = np.sqrt((P + Q))
        out = np.concatenate((out, data), axis=2)

    # ==============================================================================
    # Double Fourier Integral Analysis (DFIA)
    # ==============================================================================
    if feat['DFIA'] == 1:
        for i in tqdm(range(0, data.shape[0]), desc='Features'):
            out[i, :, :] = np.fft.fftshift(np.abs(np.fft.fft2(np.outer(data[i, :, 0], data[i, :, 1]), s=[W, W])))

    elif feat['DFIA'] == 2:
        for i in tqdm(range(0, data.shape[0]), desc='Features'):
            out[i, :, :] = np.fft.fftshift(np.angle(np.fft.fft2(np.outer(data[i, :, 0], data[i, :, 1]), s=[W, W])))

    elif feat['DFIA'] == 3:
        for i in tqdm(range(0, data.shape[0]), desc='Features'):
            out[i, :, :, 0] = np.outer(data[i, :, 0], data[i, :, 1])
            out[i, :, :, 1] = np.fft.fftshift(np.abs(np.fft.fft2(np.outer(data[i, :, 0], data[i, :, 1]), s=[W, W])))
            out[i, :, :, 2] = np.fft.fftshift(np.angle(np.fft.fft2(np.outer(data[i, :, 0], data[i, :, 1]), s=[W, W])))

    ###################################################################################################################
    # Post-Processing
    ###################################################################################################################
    # ==============================================================================
    # Replacing NaNs and Inf
    # ==============================================================================
    out = np.nan_to_num(out)
    out[out == np.inf] = 0

    ###################################################################################################################
    # Return
    ###################################################################################################################
    return out
